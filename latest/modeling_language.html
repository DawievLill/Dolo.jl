<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The dolo language · Dolo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dolo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolo.jl</a></li><li class="current"><a class="toctext" href="modeling_language.html">The dolo language</a><ul class="internal"><li><a class="toctext" href="#YAML-format-1">YAML format</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Sections-1">Sections</a></li></ul></li><li><a class="toctext" href="model_specification.html">Model Specification</a></li><li><a class="toctext" href="algos.html">Solution Algorithms</a></li><li><a class="toctext" href="simulate.html">Inspecting Solutions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="modeling_language.html">The dolo language</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolo.jl/tree/8a022d14bf33d5a2fd1aa9cf1f09ca43e55ebe5a/docs/src/modeling_language.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The dolo language</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-dolo-language-1" href="#The-dolo-language-1">The dolo language</a></h1><p>The easiest way to code a model in dolo consists in using specialized Yaml files also referred to as dolo model files.</p><h2><a class="nav-anchor" id="YAML-format-1" href="#YAML-format-1">YAML format</a></h2><p>YAML stands for Yet Another Markup Language. It is a serialization language that allows complex data structures in a human-readable way. Atomic elements are floats, integers and strings. An ordered list can be defined by separating elements with commas and enclosing them with square brackets:</p><pre><code class="language- sourceCode yaml">[1,2,3]</code></pre><p>Equivalently, it can be done on several lines, by prepending - to each line</p><pre><code class="language- sourceCode yaml">- &#39;element&#39;
- element         # quotes are optional there is no ambiguity
- third element   # this is interpreted as ``&#39;third element&#39;``</code></pre><p>Associative arrays map keys(simple strings) to arbitrary values as in the following example:</p><pre><code class="language- sourceCode yaml">{age: 18, name: peter}</code></pre><p>Mappings can also be defined on several lines, and structures can be nested by using indentation (use spaces no tabs):</p><pre><code class="language- sourceCode yaml">age: 18
name: peter
occupations:
  - school
  - guitar
friends:
  paula: {age: 18}</code></pre><p>The correspondance between the yaml definition and the resulting Julia object is very transparent. YAML mappings and lists are converted to Julia dictionaries and arrays respectively.</p><p>Special objects from the Dolo language can be created by adding a tag to yaml nodes as in the following examples:</p><blockquote><pre><code class="language- sourceCode yaml">- !AR1:
    rho: 0.9
    Sigma: [[0.1]]</code></pre></blockquote><p>or</p><blockquote><pre><code class="language- sourceCode yaml">- !Product:
     !AR1:
        rho: 0.9
        Sigma: [[0.1]]
     !AgingProcess:
          mu: 0.01     # death probability
          K: 10        # number of ages</code></pre></blockquote><p>Any model file must be syntactically correct in the Yaml sense, before the content is analysed further. More information about the YAML syntax can be found on the <a href="http://www.yaml.org/">YAML website</a>, especially from the <a href="http://www.yaml.org/">language specification</a>.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Here is an example model contained in the file <code>examples\models\rbc.yaml</code></p><p>This model can be loaded using the command:</p><pre><code class="language- sourceCode python">model = yaml_import(`examples\global_models\example.yaml`)</code></pre><p>The function yaml_import (cross) will raise errors until the model satisfies basic compliance tests. [more of it below]. In the following subsections, we describe the various syntaxic rules prevailing while writing yaml files.</p><h2><a class="nav-anchor" id="Sections-1" href="#Sections-1">Sections</a></h2><p>A dolo model consists of the following 4 or 5 parts:</p><ul><li><p>a symbols section where all symbols used in the model must be   defined</p></li><li><p>an equations section containing the list of equations</p></li><li><p>a calibration section providing numeric values for the symbols</p></li><li><p>an options section containing additional information</p></li><li><p>a covariances or markov_chain section where exogenous shocks are   defined</p></li></ul><p>These section have context dependent rules. We now review each of them in detail:</p><h3><a class="nav-anchor" id="Declaration-section-1" href="#Declaration-section-1">Declaration section</a></h3><p>This section is introduced by the symbols keyword. All symbols appearing in the model must be defined there.</p><p>Symbols must be valid Julia identifiers (alphanumeric not beginning with a number) and are case sensitive. Greek letters (save for lambda which is a keyword) are recognized. Subscripts and superscripts can be denoted by _ and __ respectively. For instance beta_i_1__d will be printed nicely as <span>$beta_{i,1}^d$</span>.</p><p>Symbols are sorted by type as in the following example:</p><pre><code class="language- sourceCode yaml">symbols:
  variables: [a, b]
  shocks: [e]
  parameters: [rho]</code></pre><p>Note that each type of symbol is associated with a symbol list (as [a,b]).</p><blockquote><p><strong>note</strong></p><p>A common mistake consists in forgetting the commas, and using spaces only. This doesn&#39;t work since two symbols are recognized as one.</p></blockquote><p>The expected types depend on the model that is being written:</p><ul><li><p>For Dynare models, all endogenous variables must be listed as   variables with the exogenous shocks being listed as shocks (as in   the example above).</p></li></ul><blockquote><p><strong>note</strong></p><p>The variables, shocks and parameters keywords correspond to the var, varexo and param keywords in Dynare respectively.</p></blockquote><ul><li><p>Global models require the definition of the parameters, and to provide</p></li></ul><p>a list of states and controls. Mixed states model also require markov_states that follow a discrete markov chain, while continuous states model need to identify the i.i.d shocks that hit the model. If the corresponding equations are given (see next subsection) optional symbols can also be defined. Among them: values, expectations.</p><h3><a class="nav-anchor" id="Declaration-of-equations-1" href="#Declaration-of-equations-1">Declaration of equations</a></h3><p>The equations section contains blocks of equations sorted by type.</p><p>Epxressions follow (roughly) the Dynare conventions. Common arithmetic operators (+,-,*,/,\^) are allowed with conventional priorities as well as usual functions (sqrt, log, exp, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh). The definitions of these functions match the definitions from the numpy package. All symbols appearing in an expression must either be declared in the symbols section or be one of the predefined functions. Any symbol s that is not a parameter is assumed to be considered at date t. Values at date t+1 and t-1 are denoted by s(1) and s(-1) respectively.</p><p>All equations are implicitly enclosed by the expectation operator <span>$E_t\left[\cdots \right]$</span>. Consequently, the law of motion for the capital</p><div>\[k_{t+1} = (1-\delta) k_{t} +  i_{t} + \epsilon_t\]</div><p>is written as:</p><pre><code class="language- sourceCode yaml">k = (1-delta)*k(-1) + i(-1)</code></pre><p>while the Euler equation</p><div>\[E_t \left[ 1=\beta \left( \frac{c_{t+1}}{c_t} + (1-\delta)+r_{t+1} \right) \right]\]</div><p>is translated by:</p><pre><code class="language- sourceCode yaml">1 = beta*(c/c(1))^(sigma)*(1-delta+rk(1))</code></pre><p>An equation can consist of one expression, or two expressions separated by =. There are two types of equation blocks:</p><ul><li><p>condition blocks</p><blockquote><p>In these blocks, each equation <code>lhs = rhs</code> define the scalar value <code>(rhs)-(lhs)</code>. A list of of such equations, i.e a block, defines a multivariate function of the appearing symbols. Certain condition blocks, can be associated with complementarity conditions separated by |` as in <code>rhs-lhs | 0 &lt; x &lt; 1</code>. In this case it is advised to omit the equal sign in order to make it easier to interpret the complementarity. Also, when complementarity conditions are used, the ordering of variables appearing in the complementarities must match the declaration order (more in section Y).</p></blockquote></li><li><p>definition blocks</p></li></ul><blockquote><p>Definition blocks differ from condition blocks in that they define a group of variables (<code>states</code> or <code>auxiliaries</code>) as a function of the right hand side.</p></blockquote><p>The types of variables appearing on the right hand side depend on the block type. The variables enumerated on the left hand-side must appear in the declaration order.</p><blockquote><p><strong>note</strong></p><p>In the RBC example, the <code>auxiliary</code> block defines variables (<code>y,c,rk,w</code>) that can be directly deduced from the states and the controls:</p><pre><code class="language- sourceCode yaml">auxiliary:
    - y = z*k^alpha*n^(1-alpha)
    - c = y - i
    - rk = alpha*y/k
    - w = (1-alpha)*y/w</code></pre><p>Note that the declaration order matches the order in which variables appear on the left hand side. Also, these variables are defined recursively: <code>c</code>, <code>rk</code> and <code>w</code> depend on the value for <code>y</code>. In contrast to the calibration block, the definition order matters. Assuming that variables were listed as (<code>c,y,rk,w</code>) the following block would provide incorrect result since <code>y</code> is not known when <code>c</code> is evaluated.</p><pre><code class="language- sourceCode yaml">auxiliary:
    - c = y - i
    - y = z*k^alpha*n^(1-alpha)
    - rk = alpha*y/k
    - w = (1-alpha)*y/w</code></pre></blockquote><h3><a class="nav-anchor" id="Calibration-section-1" href="#Calibration-section-1">Calibration section</a></h3><p>The role of the calibration section consists in providing values for the parameters and the variables. The calibration of all parameters appearing in the equation is of course strictly necessary while the  calibration of other types of variables is useful to define the steady-state or an initial guess of the steady-state.</p><p>The calibrated values are also substituted in other sections, including the shocks and options section. This is particularly useful to make the covariance matrix depend on model parameters, or to adapt the state-space to the model&#39;s calibration.</p><p>The calibration is given by an associative dictionary mapping symbols to define with values. The values can be either a scalar or an expression. All symbols are treated in the same way, and values can depend upon each other as long as there is a way to resolve them recursively.</p><p>In particular, it is possible to define a parameter in order to target a special value of an endogenous variable at the steady-state. This is done in the RBC example where steady-state labour is targeted with <code>n: 0.33</code> and the parameter <code>phi</code> calibrated so that the optimal labour supply equation holds at the steady-state (<code>chi: w/c^sigma/n^eta</code>).</p><p>All symbols that are defined in the symbols section but do not appear in the calibration section are initialized with the value nan without issuing any warning.</p><blockquote><p><strong>note</strong></p><p>No clear policy has been established yet about how to deal with undeclared symbols in the calibration section. Avoid them.</p></blockquote><h3><a class="nav-anchor" id="Shock-specification-1" href="#Shock-specification-1">Shock specification</a></h3><p>The way shocks are specified depends on the type of model. They are constructed using a the rules for mini-languages defined in section [ref].</p><h4><a class="nav-anchor" id="Distribution-1" href="#Distribution-1">Distribution</a></h4><p>For Dynare and continuous-states models, one has to specifiy a multivariate distribution of the i.i.d. process for the vector of <code>shocks</code> (otherwise shocks are assumed to be constantly 0). This is done in the distribution section. A gaussian distrubution (only one supported so far), is specified by supplying the covariance matrix as a list of lists as in the following example.</p><pre><code class="language- sourceCode yaml">distribution:

    Normal: [
            [sigma_1, 0.0],
            [0.0, sigma_2]
        ]</code></pre><h4><a class="nav-anchor" id="Markov-chains-1" href="#Markov-chains-1">Markov chains</a></h4><p>When the model is driven by an exogenous discrete markov chain, that is for DTMSCC models, shocks are defined in the <code>discrete_transition</code> section. The objects allowed in this section are: MarkovChain, AR1, MarkovTensor</p><blockquote><p>markov chain can be constructed in several ways:</p><blockquote><ul><li><p>by listing directly a list of states, and a transition matrix as   in :</p><blockquote><pre><code class="language- sourceCode yaml">discrete_transition:
    MarkovChain:   # a markov chain is defined by providing:
        - [ [0.0, -0.02]           # a list of markov states
            [0.0,  0.02]
            [-0.1, 0.02]]
        - [ [ 0.98, 0.01, 0.01],   # a transition matrix
            [ 0.10, 0.01, 0.90],
            [ 0.05, 0.05, 0.90] ]</code></pre></blockquote></li></ul><blockquote><ul><li><p>by using primitives to construct a discretized process from an   AR1:</p><blockquote><pre><code class="language- sourceCode yaml">discrete_transition:
    AR1:
        rho: 0.9
        sigma: [
                [0.01, 0.001]
                [0.001, 0.02]
            ]
        N: 3
        method: rouwenhorst   # the alternative is tauchen</code></pre></blockquote></li><li><p>by combining two processes together:</p><blockquote><pre><code class="language- sourceCode yaml">discrete_transition:
    MarkovTensor:
        - AR1:
            rho: 0.9
            sigma: [
                    [0.01, 0.001]
                    [0.001, 0.02]
                ]
            N: 3
            method: rouwenhorst   # the alternative is tauchen
        - AR1:
            rho: 0.9
            sigma: 0.01
            N: 2
            method: rouwenhorst   # the alternative is tauchen</code></pre></blockquote></li></ul></blockquote></blockquote></blockquote><h3><a class="nav-anchor" id="Domain-1" href="#Domain-1">Domain</a></h3><p>The domain section defines lower and upper bounds for the exogenous and endogenous states. For example, in the RBC model, we write:</p><pre><code class="language- sourceCode yaml">domain:
  z: [-2*sig_z/(1-rho^2)^0.5,  2*sig_z/(1-rho^2)^0.5]
  k: [ k*0.5, k*1.5]</code></pre><p>The part for <code>z</code> sets the bounds for the productivity process to be two times its asymptotic standard deviation. </p><p>The boundaries for capital are a 50% bracket around its steady-state level. </p><h3><a class="nav-anchor" id="Options-1" href="#Options-1">Options</a></h3><p>The options sections contains extra information needed to solve the model.The section follows the mini-language convention, with all calibrated values replaced by scalars and all keywords allowed.</p><p>Here we can define the grids and specify their type, Cartesian. We can also specify how many grid points we want for <code>z</code> and <code>k</code>. Here we choose 5 points for <code>z</code> and 50 points for <code>k</code>. Note that the grid points are listed in accordance with the declaration order of the variables.</p><pre><code class="language- sourceCode yaml">options:
  grid: !Cartesian
        orders: [5, 50]</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Dolo.jl</span></a><a class="next" href="model_specification.html"><span class="direction">Next</span><span class="title">Model Specification</span></a></footer></article></body></html>
