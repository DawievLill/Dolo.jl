<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solution Algorithms · Dolo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Dolo.jl logo"/></a><h1>Dolo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolo.jl</a></li><li><a class="toctext" href="modeling_language.html">The dolo language</a></li><li><a class="toctext" href="model_specification.html">Model Specification</a></li><li class="current"><a class="toctext" href="algos.html">Solution Algorithms</a><ul class="internal"><li><a class="toctext" href="#Value-iteration-1">Value iteration</a></li><li><a class="toctext" href="#Time-iteration-1">Time iteration</a></li><li><a class="toctext" href="#Improved-Time-iteration-1">Improved Time iteration</a></li><li><a class="toctext" href="#Perfect-Foresight-1">Perfect Foresight</a></li><li><a class="toctext" href="#Local-Analysis-1">Local Analysis</a></li></ul></li><li><a class="toctext" href="simulate.html">Inspecting Solutions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="algos.html">Solution Algorithms</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolo.jl/blob/master/docs/src/algos.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solution Algorithms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solution-Algorithms-1" href="#Solution-Algorithms-1">Solution Algorithms</a></h1><h2><a class="nav-anchor" id="Value-iteration-1" href="#Value-iteration-1">Value iteration</a></h2><p>Value function algorithms require a Bellman representation of the model:</p><blockquote><div>\[s_t = {\color{red} g} \left( m_{t-1}, s_{t-1}, x_{t-1}, m_t \right)\]</div><div>\[V(m_t, s_t) = \max_{\underline{x}(m_t,s_t) \leq x_t \leq \overline{x}(m_t,s_t)} {\color{red} u}\left(m_t, s_t, x_t\right) + {\color{blue} \beta} E_{m_t} V\left(m_{t+1}, s_{t+1}\right)\]</div></blockquote><p>where <span>$g$</span> is the transition function, <span>$u$</span> the instantaneous felicity function and <span>$\beta$</span> the time-discount parameter.</p><p>The solution of this problem produces naturally two functions, <span>$x=\varphi(m,s)$</span> and  <span>$V=\varphi(m,s)$</span>, for the controls and the value function respectively.</p><p>Given an initial value function <span>$V^n(m,s)$</span> applying the maximum operator produces a new and improved value function <span>$\tilde{V}^n(m,s)$</span> and a corresponding policy rule <span>$x=\varphi^n(m,s)$</span>. This is an <em>improvement</em> step.</p><p>Note that at this stage, <span>$\tilde{V}^n$</span> is not the value of following <span>$\varphi^n$</span> forever. An evaluation step performs the recursion (note the absence of a <span>$\max$</span>):</p><blockquote><div>\[x_t=\varphi^n(m_s, s_t)\]</div><div>\[s_t = {\color{red} g} \left( m_{t-1}, s_{t-1}, x_{t-1}, m_t \right)\]</div><div>\[V^{n+1}_{k+1}(m_t, s_t) = {\color{red} u}\left(m_t, s_t, x_t\right) + {\color{blue} \beta} E_{m_t} V^{n+1}_{k}\left(m_{t+1}, s_{t+1}\right)\]</div></blockquote><p>Starting from the initial guess, <span>$\tilde{V}^{n+1}$</span>, this recursion converges to the value <span>$V^{n+1}()$</span> associated to <span>$\varphi^{n+1}()$</span>. If high accuracy is not required, it is common to restrict the number of steps to perform a <em>partial evaluation</em>.</p><p>The value function algorithm implemented in Dolo follows the following scheme:</p><ol><li><p>Given an initial guess for the policy rule <span>$\varphi^0()$</span>, evaluate the corresponding value function <span>$V^0()$</span>.</p></li><li><p>Then given <span>$\varphi_n$</span>:</p><ul><li><p>perform one improvement step to get <span>$\varphi^{n+1}()$</span>, <span>$\tilde{V}^{n+1}()$</span></p></li><li><p>perform a partial evaluation of <span>$\varphi^{n+1}()$</span></p></li></ul><p>starting from <span>$\tilde{V}^{n+1}()$</span> to get <span>$V^{n+1}()$</span> using at most <span>$K$</span> steps.</p></li><li><p>Compute <span>$\eta_{n+1}=|\varphi^n-\varphi^{n+1}|$</span> and <span>$\epsilon_{n+1}=|V^n-V^{n+1}|$</span></p><ul><li><p>if <span>$\eta_{n+1}&lt;\tau_{\eta}$</span> and <span>$\epsilon_{n+1}&lt;\tau_{\epsilon}$</span>, return</p></li><li><p>else return to step 2.</p></li></ul></li></ol><p>This algorithm is controlled by the precision parameters <span>$\tau_{\eta}$</span>, <span>$\tau_{\epsilon}$</span> and the evaluation length <span>$K$</span>. Note that setting <span>$K=0$</span> corresponds to the naive (but robust ?) VFI algorithm while <span>$K$</span> high corresponds to Howard improvements which converge faster: convergence of the outer loop <span>$\varphi^n$</span> is quadratic instead of geometric.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.value_iteration" href="#Dolo.value_iteration"><code>Dolo.value_iteration</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solve for the value function and associated decision rule using value function iteration.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::NumericModel</code>: Model object that describes the current model environment.</p></li><li><p><code>pdr</code>: Initial guess for the decision rule.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>dr</code>: Solved decision rule object.</p></li><li><p><code>drv</code>: Solved value function object.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/value_iteration.jl#L247-L256">source</a></section><h2><a class="nav-anchor" id="Time-iteration-1" href="#Time-iteration-1">Time iteration</a></h2><p>We consider a model with the form:</p><blockquote><div>\[s_t = g\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \right)\]</div><div>\[0 = E_t \left[ f\left(m_t, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1} \right) \right]\]</div></blockquote><p>where <span>$g$</span> is the state transition function, and <span>$f$</span> is the arbitrage equation.</p><p>The time iteration algorithm consists in approximating the optimal controls as a function of exogenous and endogenous controls <span>$x_t = \varphi(m_t,s_t)$</span>. At step <span>$n$</span>, the current guess for the control, <span>$x(s_t) = \varphi^n(m_t, s_t)$</span>, serves as the control being used next period.</p><p>Here is an outline of the algorithm:</p><ol><li><p>Start with initial guess <span>$\varphi^0$</span></p></li><li><p>Given current guess, find the current period&#39;s  <span>$\varphi^{n+1}(m_t,s_t)$</span> controls for any <span>$(m_t,s_t)$</span> by solving (numerically)  the arbitrage equation :</p></li></ol><blockquote><div>\[0 = E_t \left[ f\left(m_t, s_{t}, \varphi^{n+1}(m_t, s_t), g(s_t, \varphi^{n+1}(m_t, s_t)), \varphi^{n}(m_{t+1},g(s_t, \varphi^{n+1}(s_t))) \right) \right]\]</div></blockquote><ol><li><p>Compute successive approximation errors <span>$\eta_n=|\varphi^{n+1}-\varphi^{n}|$</span>.</p><ul><li><p>if <span>$\eta_n$</span> smaller thatn criterion <span>$\epsilon_{\eta}$</span>, return</p></li><li><p>otherwise return to step 2</p></li></ul></li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.time_iteration" href="#Dolo.time_iteration"><code>Dolo.time_iteration</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Computes a global solution for a model via backward time iteration. The time iteration is applied to the residuals of the arbitrage equations.</p><p>If the initial guess for the decision rule is not explicitly provided, the initial guess is provided by <code>ConstantDecisionRule</code>. If the stochastic process for the model is not explicitly provided, the process is taken from the default provided by the model object, <code>model.exogenous</code></p><p><strong>Arguments</strong></p><ul><li><p><code>model::NumericModel</code>: Model object that describes the current model environment.</p></li><li><p><code>process</code>: The stochastic process associated with the exogenous variables in the model.</p></li><li><p><code>init_dr</code>: Initial guess for the decision rule.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>dr</code>: Solved decision rule.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/time_iteration.jl#L134-L146">source</a></section><p>In some cases, the solution of the Euler equation, can be obtained faster if a direct solution for optimal controls is known as a function expectation as in the following specification:</p><blockquote><div>\[s_t = g\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \right)\]</div><div>\[z_t = E_t \left[ h\left(m_{t+1}, s_{t+1}, x_{t+1} \right) \right]\]</div><div>\[x_t = d(m_t, s_t, z_t)\]</div></blockquote><p>This information can be used by passing the <code>solver=Dict(:type=&gt;:direct)</code> option to the time_iteration function, or by using the devoted function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.time_iteration_direct" href="#Dolo.time_iteration_direct"><code>Dolo.time_iteration_direct</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Computes a global solution for a model via backward time iteration. The time iteration is  applied directly to the decision rule of the model.</p><p>If the initial guess for the decision rule is not explicitly provided, the initial guess is provided by <code>ConstantDecisionRule</code>. If the stochastic process for the model is not explicitly provided, the process is taken from the default provided by the model object, <code>model.exogenous</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::NumericModel</code>: Model object that describes the current model environment.</p></li><li><p><code>process</code>: The stochastic process associated with the exogenous variables in the model.</p></li><li><p><code>init_dr</code>: Initial guess for the decision rule.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>dr</code>: Solved decision rule.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/time_iteration_direct.jl#L1-L14">source</a></section><h2><a class="nav-anchor" id="Improved-Time-iteration-1" href="#Improved-Time-iteration-1">Improved Time iteration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.improved_time_iteration" href="#Dolo.improved_time_iteration"><code>Dolo.improved_time_iteration</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Computes a global solution for a model via backward Improved Time Iteration. The algorithm is applied to the residuals of the arbitrage equations. The idea is to solve the system G(x) = 0 as a big nonlinear system in x, where the inverted Jacobian matrix is approximated by an infinite sum (Neumann series).</p><p>If the initial guess for the decision rule is not explicitly provided, the initial guess is provided by <code>ConstantDecisionRule</code>. If the stochastic process for the model is not explicitly provided, the process is taken from the default provided by the model object, <code>model.exogenous</code></p><p><strong>Arguments</strong></p><ul><li><p><code>model::NumericModel</code>: Model object that describes the current model environment.</p></li><li><p><code>dprocess</code>: The stochastic process associated with the exogenous variables in the model.</p></li><li><p><code>init_dr</code>: Initial guess for the decision rule.</p></li><li><p><code>maxbsteps</code> Maximum number of backsteps.</p></li><li><p><code>verbose</code> Set &quot;true&quot; if you would like to see the details of the infinite sum convergence.</p></li><li><p><code>smaxit</code> Maximum number of iterations to compute the Neumann series.</p></li><li><p><code>complementarities</code></p></li><li><p><code>compute_radius</code></p></li><li><p><code>trace</code> Record Iteration informations</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>sol</code>: Improved Time Iteration results</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/improved_time_iteration.jl#L3-L21">source</a></section><h2><a class="nav-anchor" id="Perfect-Foresight-1" href="#Perfect-Foresight-1">Perfect Foresight</a></h2><p>Consider a series for the exogenous process <span>$(m_t)_{0 \leq t \leq T}$</span>. The perfect foresight problem consists in finding the path of optimal controls <span>$(x_t)_{0 \leq t \leq T}$</span> and corresponding states <span>$(s_t)_{0 \leq t \leq T}$</span> such that:</p><blockquote><div>\[s_t = g\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \right)\]</div><div>\[0 = E_t \left( f\left(m_{t}, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1}\right) \right) \ \perp \ \underline{u} &lt;= x_t &lt;= \overline{u}\]</div></blockquote><p>Special conditions apply for the initial state and controls. Initial state <span>$s_0$</span> is given exogenously, or determined so that it corresponds for a steady-state corresponding to <span>$m_0$</span>. Final states and controls are determined by assuming the exogenous process satisfies <span>$m_t=m_T$</span> for all <span>$t\leq T$</span> and optimality conditions are satisfied in the last period:</p><div>\[f(m_T, s_T, x_T, m_T,s_T, x_T) \perp \underline{u} \leq x_T \leq \overline{u}\]</div><p>.</p><p>We assume that <span>$\underline{u}$</span> and <span>$\overline{u}$</span> are constants. This is not a big restriction since the model can always be reformulated in order to meet that constraint, by adding more equations.</p><p>The stacked system of equations satisfied by the solution is:</p><blockquote><table><tr><th>Transition</th><th>Arbitrage</th></tr><tr><td><span>$s_0 = \overline{s_0}$</span></td><td><span>$f(m_0, s_0, x_0, m_1, s_1, x_1) \perp \underline{u} &lt;= x_0 &lt;= \overline{u}$</span></td></tr><tr><td><span>$s_1 = g(m_0, s_0, x_0, m_1)$</span></td><td><span>$f(m_1, s_1, x_1, m_2, s_2, x_2) \perp \underline{u} &lt;= x_1 &lt;= \overline{u}$</span></td></tr><tr><td>...</td><td>...</td></tr><tr><td><span>$s_T = g(m_{T-1}, s_{T-1}, x_{T-1}, m_T)$</span></td><td><span>$f(m_T, s_T, x_T, m_T, s_T, x_T) \perp \underline{u} &lt;= x_T &lt;= \overline{u}$</span></td></tr></table></blockquote><p>The system is solved using a nonlinear solver.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.perfect_foresight" href="#Dolo.perfect_foresight"><code>Dolo.perfect_foresight</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Document pf.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/perfect_foresight.jl#L1-L3">source</a></section><h2><a class="nav-anchor" id="Local-Analysis-1" href="#Local-Analysis-1">Local Analysis</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.residuals" href="#Dolo.residuals"><code>Dolo.residuals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">residuals(model::AModel, [calib::ModelCalibration])::Dict</code></pre><p>Compute the steady state residuals for the aribtrage and transition equations of <code>model</code>, when these functions are evaluated at the data in <code>calib</code>. If no <code>calib</code> is provided, <code>model.calibration</code> will be used.</p><p>See the docstring for <code>find_deterministic_equilibrium</code> for more information</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/steady_state.jl#L70-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.find_deterministic_equilibrium" href="#Dolo.find_deterministic_equilibrium"><code>Dolo.find_deterministic_equilibrium</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">find_deterministic_equilibrium(model::AModel, [calib::ModelCalibration])</code></pre><p>Solve for the steady state equilibrium of <code>model</code>, data in <code>cailb</code> to fill in parameter values and provide an initial guess for the states and controls. When no calibration is passed <code>model.calibration</code> is used</p><p>The <code>exogenous</code> variables at time t-1 (<code>m</code>) and t (<code>M</code>) are set to <code>calib[:exogenous]</code>.</p><p>The deterministic equilibrium is found by solving for vectors <code>s</code> and <code>x</code>, such that</p><ol><li><p><code>s = transition(m, s, x, m, p)</code></p></li><li><p><code>0 = arbitrage(m, s, x, m, s, x, p)</code></p></li></ol></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/steady_state.jl#L50-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolo.perturb" href="#Dolo.perturb"><code>Dolo.perturb</code></a> — <span class="docstring-category">Function</span>.</div><div><p>TBD</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolo.jl/blob/0865f6c90ca934da5fda49f12303ae7deb78a3df/src/algos/perturbation.jl#L103-L105">source</a></section><footer><hr/><a class="previous" href="model_specification.html"><span class="direction">Previous</span><span class="title">Model Specification</span></a><a class="next" href="simulate.html"><span class="direction">Next</span><span class="title">Inspecting Solutions</span></a></footer></article></body></html>
