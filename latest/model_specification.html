<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Specification · Dolo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Dolo.jl logo"/></a><h1>Dolo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolo.jl</a></li><li><a class="toctext" href="modeling_language.html">The dolo language</a></li><li class="current"><a class="toctext" href="model_specification.html">Model Specification</a><ul class="internal"><li><a class="toctext" href="#Variable-types-1">Variable types</a></li></ul></li><li><a class="toctext" href="algos.html">Solution Algorithms</a></li><li><a class="toctext" href="simulate.html">Inspecting Solutions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="model_specification.html">Model Specification</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolo.jl/tree/130e1f7aeaf980de31d680428ccedbae3565ef1d/docs/src/model_specification.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Model Specification</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Model-Specification-1" href="#Model-Specification-1">Model Specification</a></h1><h2><a class="nav-anchor" id="Variable-types-1" href="#Variable-types-1">Variable types</a></h2><p>The following types of variables can be used in models:</p><blockquote><ul><li><p><code>exogenous</code> (<code>m</code>)</p></li><li><p><code>states</code> (<code>s</code>)</p></li><li><p><code>controls</code> (<code>x</code>)</p></li><li><p><code>auxiliaries</code> (<code>y</code>)</p></li><li><p><code>rewards</code> (<code>r</code>)</p></li><li><p><code>values</code> (<code>v</code>)</p></li><li><p><code>expectations</code> (<code>z</code>)</p></li><li><p><code>parameters</code> (<code>p</code>)</p></li></ul></blockquote><p>Symbol types that are present in a model are always listed in that order.</p><h3><a class="nav-anchor" id="State-space-1" href="#State-space-1">State-space</a></h3><p>Decisions are characterized by a vector <span>$m$</span> of <em>exogenous</em> variables (exogenous states) and by a vector <span>$s$</span> of endogenous <em>states</em>. The unknown vector of controls <span>$x$</span> is a function <span>$\varphi$</span> of the states such that:</p><blockquote><div>\[x = \varphi(m,s)\]</div></blockquote><p>The function <span>$\varphi$</span> is typically approximated by the solution algorithm. It can be either a Taylor expansion, or an interpolating object (splines, smolyak). Once obtained, it can be evaluated at any point of the the state space (represented by a couple of vectors), or at a list of points (of couple of matrices):</p><pre><code class="language- sourceCode julia">dr = time_iteration(model)
m0 = model.calibration[:states]
s0 = model.calibration[:states]
dr(m0,s0)                               # evaluates at the steady-state
dr([0.0;-0.01;-0.1], [2.5;2.5;2.5])     # evaluates at a list of points</code></pre><p>A decision rule is defined on two discretized grids: one for the exogenous states and one for the endogenous ones. If the exogenous grid points are numbered by <span>$i$</span>, we can define non-ambiguously <span>$x = \varphi(i,s)$</span> as  <span>$\varphi(m_i,s)$</span>, which corresponds to the following code:</p><pre><code class="language- sourceCode julia">dr(2,s0)                 # evaluates at the second exogenous point
dr(2, [2.5;2.5;2.5])     # evaluates at a list of points</code></pre><h3><a class="nav-anchor" id="Valid-equations-1" href="#Valid-equations-1">Valid equations</a></h3><p>The various equations understood by Dolo are descrbed below:</p><p>&lt;!– would be cool to know how to make comments ;-) –&gt;</p><h4><a class="nav-anchor" id="Transitions-1" href="#Transitions-1">Transitions</a></h4><pre><code class="language-none">- name: `transition`
- short name: `g`</code></pre><p>Transitions are given by a function <span>$g$</span> such that at all times:</p><div>\[s_t = g(m_{t-1}, s_{t-1}, x_{t-1}, m_t)\]</div><p>where <span>$m_t$</span> is a vector-valued exogenous process.</p><blockquote><p><strong>note</strong></p><p>In the RBC model, the vector of endogenous states is <span>$s_t=(a_t,k_t)$</span>. The transitions are:</p><blockquote><div>\[a_t = \rho a_{t-1} + \epsilon_t\]</div><div>\[k_t = (1-\delta)k_{t-1} + i_{t-1}\]</div></blockquote><p>If <span>$\epsilon_t$</span> follow a normal distribution with variance <span>$\sigma_{\epsilon}$</span>, the yaml file is amended with:</p><pre><code class="language- sourceCode yaml">symbols:
    states: [a,k]
    controls: [i]
    exogenous: [epsilon]
    ...
equations:
    transition:
        a = rho*a(-1) + e
        k = k(-1)*(1-delta) + i(-1)
exogenous: !Normal
    Sigma: [[sigma_epsilon]]</code></pre><p>Note that transition equations must list states in declaration order. Also, in this example the productivity process <span>$a_t$</span> is essentially an exogenous AR1 process. Declaring it as such (instead of <span>$\epsilon$</span>), provides additional information to the solvers and can lead to faster solution time.</p></blockquote><h4><a class="nav-anchor" id="Auxiliary-variables-/-Definitions-1" href="#Auxiliary-variables-/-Definitions-1">Auxiliary variables / Definitions</a></h4><pre><code class="language-none">- name: `auxiliary`
- short name: `a`</code></pre><p>In order to reduce the number of variables, it is useful to define auxiliary variables <span>$y_t$</span> using a function <span>$a$</span> such that:</p><div>\[y_t = a(m_t, s_t, x_t)\]</div><p>These variables are defined in a special <code>definitions</code> block, outside of <code>equations</code>. When auxiliary variables appear in an equation they are automatically substituted by the corresponding expression in <span>$m_t$</span>,<span>$s_t$</span> and <span>$x_t$</span>.</p><blockquote><p><strong>note</strong></p><p>In the RBC model, three auxiliary variables are defined <span>$y_t, c_t, r_{k,t}$</span> and <span>$w_t$</span>. They are a closed form function of <span>$a_t, k_t, i_t, n_t$</span>. Defining these variables speeds up computation since they are don&#39;t need to be solved for or interpolated.</p></blockquote><h4><a class="nav-anchor" id="Utility-function-and-Bellman-equation-1" href="#Utility-function-and-Bellman-equation-1">Utility function and Bellman equation</a></h4><pre><code class="language-none">- name: `utility`
- short name: `u`</code></pre><p>The (separable) value equation defines the value <span>$v_t$</span> of a given policy as:</p><div>\[v_t = u(m_t,s_t,x_t) + \beta E_t \left[ v_{t+1} \right]\]</div><p>This gives rise to the Bellman eqution:</p><blockquote><div>\[v_t = \max_{x_t} \left( u(m_t, s_t,x_t) + \beta E_t \left[ v_{t+1} \right] \right)\]</div></blockquote><p>These two equations are characterized by the reward function <span>$u$</span> and the discount rate <span>$\beta$</span>. Function <span>$u$</span> defines the vector of symbols <code>rewards</code>. Since the definition of <span>$u$</span> alone is not sufficient, the parameter used for the discount factor must be given to routines that compute the value. Several values can be computed at once, if <span>$U$</span> is a vector function and <span>$\beta$</span> a vector of discount factors, but in that case in cannot be used to solve for the Bellman equation.</p><blockquote><p><strong>note</strong></p><p>Our RBC example defines the value as <span>$v_t = \frac{(c_t)^{1-\gamma}}{1-\gamma}-\chi \frac{(n_t)^{1+\eta}}/{1+\eta} + \beta E_t v_{t+1}$</span>. This information is coded using: </p><pre><code class="language- sourceCode yaml">symbols:
    ...
    rewards: [r]

equations:
    ...
    utility:
        - r = c^(1-gamma)/(1-gamma)- chi*n^(1+eta)/(1+eta)

calibration:
    ...
    beta: 0.96   # beta is the default name of the discount</code></pre></blockquote><h4><a class="nav-anchor" id="Value-1" href="#Value-1">Value</a></h4><pre><code class="language-none">- name: `value`
- short name: `w`</code></pre><p>A more general updating equation can be useful to express non-separable utilities or prices. The vector of (generalized) values <span>$v^{*}$</span> are defined by a function <code>w</code> such that:</p><div>\[v_t = w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1})\]</div><p>As in the separable case, this function can either be used to compute the value of a given policy <span>$x=\varphi()$</span> or in order solve the generalized Bellman equation:</p><div>\[v_t = \max_{x_t} \left( w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) \right)\]</div><blockquote><p><strong>note</strong></p><p>Instead of defining the rewards of the RBC example, one can instead define a value updating equation:</p><pre><code class="language- sourceCode yaml">symbols:
    ...
    values: [v]

equations:
    ...
    value:
        - v = c^(1-gamma)/(1-gamma)*(1-n...) + beta*v(1)</code></pre></blockquote><h4><a class="nav-anchor" id="Boundaries-1" href="#Boundaries-1">Boundaries</a></h4><pre><code class="language-none">- name: `controls_lb` and `controls_ub`
- short name: `lb` and `ub`</code></pre><p>The optimal controls must also satisfy bounds that are function of states. There are two functions <span>$\underline{b}()$</span> and <span>$\overline{b}()$</span> such that:</p><div>\[\underline{b}(m_t, s_t) \leq x_t \leq \overline{b}(m_t, s_t)\]</div><blockquote><p><strong>note</strong></p><p>In our formulation of the RBC model we have excluded negative investment, implying <span>$i_t \geq 0$</span>. On the other hand, labour cannot be negative so that we add lower bounds to the model:</p><pre><code class="language- sourceCode yaml">equations:
    ...
    controls_lb:
        i = 0
        n = 0</code></pre><p>Specifying the lower bound on labour actually has no effect since agents endogeneously choose to work a positive amount of time in order to produce some consumption goods. As for upper bounds, it is not necessary to impose some: the maximum amount of investment is limited by the Inada conditions on consumption. As for labour <code>n</code>, it can be arbitrarly large without creating any paradox. Thus the upper bounds are omitted (and internally treated as infinite values).</p></blockquote><h4><a class="nav-anchor" id="Euler-equation-1" href="#Euler-equation-1">Euler equation</a></h4><pre><code class="language-none">- name: `arbitrage` (`equilibrium`)
- short name: `f`</code></pre><p>A general formulation of the Euler equation is:</p><div>\[0 = E_t \left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \right]\]</div><p>Note that the Euler equation and the boundaries interact via &quot;complentarity equations&quot;. Evaluated at one given state, with the vector of controls <span>$x=(x_1, ..., x_i, ..., x_{n_x})$</span>, the Euler equation gives us the residuals <span>$r=(f_1, ..., f_i, ..., f_{n_x})$</span>. Suppose that the <span>$i$</span>-th control <span>$x_i$</span> is supposed to lie in the interval <span>$[ \underline{b}_i, \overline{b}_i ]$</span>. Then one of the following conditions must be true:</p><ul><li><p><span>$f_i$</span> = 0</p></li><li><p><span>$f_i&lt;0$</span> and <span>$x_i=\overline{b}_i$</span></p></li><li><p><span>$f_i&gt;0$</span> and <span>$x_i=\underline{b}_i$</span></p></li></ul><p>By definition, this set of conditions is denoted by:</p><ul><li><p><span>$f_i = 0 \perp \underline{b}_i \leq x_i \leq \overline{b}_i$</span></p></li></ul><p>These notations extend to a vector setting so that the Euler equations can also be written:</p><div>\[0 = E_t \left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \right] \perp \underline{b}(m_t, s_t) \leq x_t \leq \overline{b}(m_t, s_t)\]</div><p>Specifying the boundaries together with Euler equation, or providing them separately is exactly equivalent. In any case, when the boundaries are finite and occasionally binding, some attention should be devoted to write the Euler equations in a consistent manner. In particular, note that the Euler equations are order-sensitive.</p><p>The Euler conditions, together with the complementarity conditions typically often come from Kuhn-Tucker conditions associated with the Bellman problem, but that is not true in general.</p><blockquote><p><strong>note</strong></p><p>The RBC model has two Euler equations associated with investment and labour supply respectively. They are added to the model as:</p><pre><code class="language- sourceCode yaml">arbitrage:
    - 1 - beta*(c/c(1))^(sigma)*(1-delta+rk(1))   | 0 &lt;= i &lt;= inf
    - w - chi*n^eta*c^sigma                       | 0 &lt;= n &lt;= inf</code></pre><p>Putting the complementarity conditions next to the Euler equations, instead of entering them as separate equations, helps to check the sign of the Euler residuals when constraints are binding. Here, when investment is less desirable, the first expression becomes bigger. When the representative agent is prevented from investing less due to the constraint (i.e. <span>$i_t=0$</span>), the expression is then <em>positive</em>, consistent with the complementarity conventions.</p></blockquote><h4><a class="nav-anchor" id="Expectations-1" href="#Expectations-1">Expectations</a></h4><pre><code class="language-none">- name: `expectation`
- short name: `h`</code></pre><p>The vector of explicit expectations <span>$z_t$</span> is defined by a function <span>$h$</span> such that:</p><div>\[z_t = E_t \left[ h(m_{t+1}, s_{t+1},x_{t+1}) \right]\]</div><pre><code class="language- sourceCode">In the RBC example, one can define the expected value tomorrow of one additional unit invested tomorrow:

.. math::

    m_t=\beta*(c_{t+1}^(-\sigma)*(1-\delta+r_{k,t+1})

 It is a pure expectational variable in the sense that it is solely determined by future states and decisions. In the model file, it would be defined as:

.. code: yaml

    symbols:
        ...
        expectations: [z]

    equations:
        ...
        - z = beta*(c(1))^(-sigma)*(1-delta+rk(1))</code></pre><h4><a class="nav-anchor" id="Generalized-expectations-1" href="#Generalized-expectations-1">Generalized expectations</a></h4><pre><code class="language-none">- name: `expectation_2`
- short name: `h_2`</code></pre><p>The vector of generalized explicit expectations <span>$z_t$</span> is defined by a function <span>$h^{\star}$</span> such that:</p><div>\[z_t = E_t \left[ h^{\star}(m_t,s_t,x_t,m_{t+1},s_{t+1},x_{t+1}) \right]\]</div><h4><a class="nav-anchor" id="Euler-equation-with-expectations-1" href="#Euler-equation-with-expectations-1">Euler equation with expectations</a></h4><pre><code class="language-none">- name: `arbitrage_2` (`equilibrium_2`)
- short name: `f_2`</code></pre><p>If expectations are defined using one of the two preceding definitions, the Euler equation can be rewritten as:</p><div>\[0 = f(m_t, s_t, x_t, z_t) \perp \underline{b}(m_t, s_t) \leq x_t \leq \overline{b}(m_t, s_t)\]</div><blockquote><p><strong>note</strong></p><p>Given the definition of the expectation variable <span>$m_t$</span>, today&#39;s consumption is given by: <span>$c_t = z_t^\left(-\frac{1}{\sigma}\right)$</span> so the Euler equations are rewritten as:</p><pre><code class="language- sourceCode yaml">arbitrage_2:
    - 1 - beta*(c)^(sigma)/m   | 0 &lt;= i &lt;= inf
    - w - chi*n^eta*c^sigma    | 0 &lt;= n &lt;= inf</code></pre><p>Note the type of the arbitrage equation (<code>arbitrage_2</code> instead of <code>arbitrage</code>).</p><p>However <span>$c_t$</span> is not a control itself,</p><blockquote><p>but the controls <span>$i_t, n_t$</span> can be easily deduced:</p></blockquote><p>..math:</p><pre><code class="language-none">n_t = ((1-\alpha) z_t k_t^\alpha m_t/chi)^(1/(eta+\alpha))
i_t = z_t k_t^\alpha n_t^(1-\alpha) - (m_t)^(-1/\sigma)</code></pre><p>This translates into the following YAML code:</p><pre><code class="language- sourceCode yaml">equations:
    - n = ((1-alpha)*a*k^alpha*m/chi)^(1/(eta+alpha))
    - i = z*k^alpha*n^(1-alpha) - m^(-1/sigma)</code></pre></blockquote><h4><a class="nav-anchor" id="Direct-response-function-1" href="#Direct-response-function-1">Direct response function</a></h4><pre><code class="language-none">- name: `direct_response`
- short name: `d`</code></pre><p>In some simple cases, there a function <span>$d()$</span> giving an explicit definition of the controls:</p><div>\[x_t = d(m_t, s_t, z_t)\]</div><p>Compared to the preceding Euler equation, this formulation saves computational time by removing the need to solve a nonlinear system to recover the controls implicitly defined by the Euler equation.</p><footer><hr/><a class="previous" href="modeling_language.html"><span class="direction">Previous</span><span class="title">The dolo language</span></a><a class="next" href="algos.html"><span class="direction">Next</span><span class="title">Solution Algorithms</span></a></footer></article></body></html>
